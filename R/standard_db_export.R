#' Ion Standard Fragmentations
#'
#' @param nested_ions generated by \code{\link{extract_standard_ions}}
#' @param query_ionIds subset of ionIds to use (or NULL for all)
#' @param minimum_ic_fraction A value between 0 and 1 indicating for a given peak the fraction of total signal for it to be used for matching.
#' @inheritParams sum_spectra_by_class
#' @param save_name save name of msp output file
#' @param dir_path path to output folder
#'
#' @return writes a set of .msp files for each energy_type to dir_path
#'
#' @export
generate_msp <- function(nested_ions,
                         query_ionIds = NULL,
                         normalize_intensities = FALSE,
                         minimum_ic_fraction = 0.001,
                         save_name,
                         dir_path) {
  stopifnot(class(query_ionIds) %in% c("numeric", "integer", "NULL"))
  stopifnot(
    class(normalize_intensities) == "logical",
    length(normalize_intensities) == 1,
    normalize_intensities %in% c(TRUE, FALSE)
  )
  stopifnot(
    class(minimum_ic_fraction) == "numeric",
    length(minimum_ic_fraction) == 1,
    minimum_ic_fraction > 0,
    minimum_ic_fraction < 1
  )
  stopifnot(class(save_name) == "character", length(save_name) == 1)
  stopifnot(
    class(dir_path) == "character",
    length(dir_path) == 1,
    file.exists(dir_path)
  )

  if (!is.null(query_ionIds)) {
    nested_ions <- nested_ions %>%
      dplyr::filter(ionId %in% query_ionIds)
  }

  summed_spectra_sets <- nested_ions %>%
    # make sure there is some fragmentation data
    dplyr::filter(!purrr::map_lgl(stdFragmentations, is.null)) %>%
    dplyr::mutate(spectra_classes = purrr::map(
      stdFragmentations,
      sum_spectra_by_class,
      normalize_intensities = normalize_intensities,
      minimum_ic_fraction = minimum_ic_fraction
    ))

  db_ions <- summed_spectra_sets %>%
    dplyr::select(-stdFragmentations, -spectra_classes) %>%
    tidyr::unnest(stdCompounds)

  db_spectra <- summed_spectra_sets %>%
    dplyr::select(-stdCompounds, -stdFragmentations) %>%
    tidyr::unnest(spectra_classes)

  # Add ions missing spectra to fit with Maven #92
  db_ions_missing_spectra <- nested_ions %>%
    dplyr::filter(purrr::map_lgl(stdFragmentations, is.null)) %>%
    tidyr::unnest(stdCompounds) %>%
    dplyr::select(-stdFragmentations)

  db_ions <- rbind(db_ions, db_ions_missing_spectra)

  # write standard data to msp
  format_msp_list(
    db_ions = db_ions,
    db_spectra = db_spectra,
    save_name,
    dir_path
  )
}

#' Sum Spectra by Class
#'
#' @param stdFragmentation subsets of \code{nested_ions}
#' @param normalize_intensities TRUE/FALSE whether to normalize spectra
#'   before summing them
#' @param minimum_ic_fraction A value between 0 and 1 indicating for a given peak the fraction of total signal for it to be used for matching.
sum_spectra_by_class <- function(stdFragmentation,
                                 normalize_intensities = FALSE,
                                 minimum_ic_fraction = 0.001) {
  checkmate::assertDataFrame(stdFragmentation)
  checkmate::assertLogical(normalize_intensities, len = 1)
  checkmate::assertNumber(minimum_ic_fraction, lower = 0, upper = 1)

  if (normalize_intensities) {
    stdFragmentation <- stdFragmentation %>%
      dplyr::mutate(fragData = purrr::map(fragData, spectra_normalize))
  }

  if (minimum_ic_fraction != 0) {
    stdFragmentation <- stdFragmentation %>%
      dplyr::mutate(fragData = purrr::map(
        fragData,
        clamr::spectra_filter_fragments,
        minimum_ic_fraction = minimum_ic_fraction
      ))
  }

  stdFragmentation %>%
    tidyr::nest(class_fragmentations = -energy_class) %>%
    dplyr::mutate(spectra_set = purrr::map(
      class_fragmentations,
      function(x) {
        x$fragData
      }
    )) %>%
    dplyr::mutate(spectra_set = purrr::map(
      spectra_set,
      dplyr::bind_rows
    )) %>%
    dplyr::mutate(spectra = purrr::map(
      spectra_set,
      clamr::sum_spectra,
      MS1tol = clamr::format_mass_accuracy_input(10, "ppm")
    )) %>%
    dplyr::select(energy_class, spectra)
}

#' Format MSP List
#'
#' @param db_ions list of attributes produced by \code{\link{generate_msp}}
#' @param db_spectra list of spectra produced by \code{\link{generate_msp}}
#' @inheritParams generate_msp
#'
#' @return writes one tsv for each energy set
format_msp_list <- function(db_ions, db_spectra, save_name, dir_path) {
  ion_attr_table <- tibble::tribble(
    ~attribute, ~new_attribute,
    "compoundName", "Name",
    "chirality", "chirality",
    "ionIdlabel", "ID",
    "mass", "MW",
    "precursorMz", "precursorMz",
    "precursorCharge", "precursorCharge",
    "formula", "FORMULA",
    "adductName", "ADDUCT",
    "mode", "ion mode",
    "rtObserved", "RT",
    "systematicCompoundId", "systematic ID",
    "inchikey", "inchikey",
    "smiles", "smiles"
  )

  nested_ions <- db_ions %>%
    dplyr::mutate(ionIdlabel = ionId) %>%
    tidyr::gather(attribute, value, -ionId) %>%
    dplyr::inner_join(ion_attr_table, by = "attribute") %>%
    dplyr::mutate(attribute = factor(
      new_attribute,
      levels = ion_attr_table$new_attribute
    )) %>%
    dplyr::select(ionId, attribute, value) %>%
    dplyr::arrange(attribute) %>%
    tidyr::nest(ions = -ionId)

  msp_entries <- nested_ions %>%
    dplyr::left_join(db_spectra, by = "ionId") %>%
    dplyr::mutate(msp_entries = purrr::map2(
      ions,
      spectra,
      format_one_msp_entry
    ))

  energy_sets <- msp_entries %>%
    plyr::dlply(.variables = "energy_class", .fun = tibble::as_tibble)

  # msp entries with no associated spectra have type NA, which
  #   are added to all libraries
  NA_output <- NULL
  if (!is.null(energy_sets$`NA`)) {
    NA_output <- energy_sets[["NA"]]$msp_entries %>%
      purrr::map(function(x) {
        dplyr::bind_rows(x, tibble::tibble(entry = ""))
      }) %>%
      dplyr::bind_rows()
  }

  for (j in seq_along(energy_sets)) {
    energy_name <- names(energy_sets)[j]

    if (energy_name != "NA") {
      energy_filename <- paste0(save_name, "-", energy_name, ".msp")

      output <- energy_sets[[j]]$msp_entries %>%
        purrr::map(function(x) {
          dplyr::bind_rows(x, tibble::tibble(entry = ""))
        }) %>%
        dplyr::bind_rows()

      # NA type gets added to every other type
      if (!is.null(NA_output)) {
        output <- rbind(output, NA_output)
      }

      output_file <- file.path(dir_path, energy_filename)
      readr::write_tsv(
        output,
        file = output_file,
        col_names = FALSE
      )
      system(glue::glue("chmod 777 {msp_output_file}", msp_output_file = output_file))
    }
  }

  invisible(0)
}

#' Format One MSP entry
#'
#' @param one_ion one ion from \code{\link{format_msp_list}}
#' @param one_spectra one ion from \code{\link{format_msp_list}}
#'
#' @return a one column tibble
format_one_msp_entry <- function(one_ion, one_spectra) {
  flat_ion <- one_ion %>%
    dplyr::mutate(entry = paste(attribute, value, sep = ": ")) %>%
    dplyr::select(entry)

  if (is.null(one_spectra) || one_spectra == "NULL") {
    peak_count <- tibble::tibble(entry = paste0("NumPeaks: 0"))

    one_msp_entry <- do.call(dplyr::bind_rows, list(flat_ion, peak_count))
  } else {
    peak_count <- tibble::tibble(
      entry = paste0("NumPeaks: ", nrow(one_spectra))
    )

    flat_spectra <- if ("label" %in% colnames(one_spectra)) {
      one_spectra %>%
        dplyr::mutate(entry = paste(mz, ic, label, sep = " ")) %>%
        dplyr::select(entry)
    } else {
      one_spectra %>%
        dplyr::mutate(entry = paste(mz, ic, sep = " ")) %>%
        dplyr::select(entry)
    }

    one_msp_entry <- do.call(
      dplyr::bind_rows,
      list(flat_ion, peak_count, flat_spectra)
    )
  }

  one_msp_entry
}
