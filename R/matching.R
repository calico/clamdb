#' Align Features to Standards
#'
#' For each peakgroup in a dataset identify candidate standard compounds which it could match,
#' and align experimental and standard features for each putative match.
#'
#' @param clamr_config a named list of mass spec parameters with special formatting of instrument tolerances generated by \code{\link{build_clamr_config}}.
#' @param mzroll_db_con a connection to a mzroll database as produced by \code{\link{mzroll_db_sqlite}}
#' 
#' @param peakgroups optionally, a subset of peakgroups to generate aligned features from.
#' 
#' @inheritParams standard_db_populate_data
#' @param matched_method string representation of configuration details, from standards DB
#'
#' @export
align_features_to_standards <- function(mzroll_db_con, clamr_config, peakgroups = NULL, mass_spec_standards_con, matched_method) {
  clamr::test_mzroll_db_con_schema(mzroll_db_con)
  clamr::require_tolerances(clamr_config, c(1L, 2L))

  stopifnot(class(peakgroups) %in% c("numeric", "integer", "NULL"))
  stopifnot(class(matched_method) == "character", length(matched_method) == 1)

  # extract experimental peakgroup features

  baseline_label <- ifelse(clamr_config$mode == "positive", "[M+H]+", "[M-H]-")

  # match peaks and scans to peakgroups
  nested_peakgroup_features <- clamr::nest_peakgroup_features(mzroll_db_con) %>%
    dplyr::mutate(adductName = ifelse(adductName == "" | is.na(adductName), baseline_label, adductName)) %>%
    dplyr::mutate(adductName = ifelse(adductName == "[M+H]", "[M+H]+", adductName)) %>%
    dplyr::mutate(adductName = ifelse(adductName == "[M-H]", "[M-H]-", adductName))

  # narrow features to peakgroups of interest (or all peakgroups if peakgroups = NULL)
  if (!is.null(peakgroups)) {
    nested_peakgroup_features <- nested_peakgroup_features %>%
      dplyr::filter(groupId %in% peakgroups)
  }

  # Do not use RT for lipids (as of right now), use RT for all other compound classes
  chemical_class <- clamr_config$chemical_class

  # query all standard data which is relevant for the experiment
  standards_data <- get_standards_subset(mass_spec_standards_con,
    matched_method = matched_method,
    r_scripts_path = clamr_config$r_scripts_path,
    chemical_class = chemical_class,
    ms_mode = clamr_config$mode,
    chromatographic_method = clamr_config$chromatographic_method
  )

  # determine which standards are within mass tolerance of each peakgroup
  before <- Sys.time()
  id_candidates <- match_id_candidates(mzroll_db_con, clamr_config, nested_peakgroup_features, standards_data)
  after <- Sys.time()
  debugr::dwatch(msg = paste("Matched id candidates from standards DB to data in", difftime(after, before, units = "secs"), "seconds"))
  # Matched id candidates from standards DB to data in 0.769484043121338 s (2019-05-09)

  before <- Sys.time()

  # extract the fragmentation profiles of ions @ experimental energies / chromatographic methods
  nested_standards <- extract_standard_ions(standards_data,
    query_ionIds = id_candidates$ionId,
    chromatographic_method = clamr_config$chromatographic_method,
    collision_energies = clamr_config$collision_energies,
    is_lipid = clamr_config$chemical_class == "lipid"
  )
  after <- Sys.time()
  debugr::dwatch(msg = paste("Generated nested_standards from standards_data, chromatographic_method, and collision_energies in", difftime(after, before, units = "secs"), "seconds"))

  before <- Sys.time()

  peakgroup_standard_features <- id_candidates %>%
    dplyr::inner_join(nested_peakgroup_features, by = "groupId") %>%
    dplyr::left_join(nested_standards, by = "ionId")

  after <- Sys.time()
  debugr::dwatch(msg = paste("Generated peakgroup_standard_features from id_candidates in", difftime(after, before, units = "secs"), "seconds"))

  peakgroup_standard_features
}

#' Match ID Candidates
#'
#' Determine what standards are within MS1 mass tolerance of a set of nested_peakgroup_features
#'
#' @param mzroll_db_con a connection to a mzroll database as produced by \code{\link{mzroll_db_sqlite}}
#' @param clamr_config a named list of mass spec parameters with special formatting of instrument tolerances generated by \code{\link{build_clamr_config}}.
#' @param nested_peakgroup_features generated from \code{\link[clamr]{nest_peakgroup_features}}.
#' @param standards_data generated from \code{\link{query_standards_subset}}.
#'
#' @return id_candidates: a tibble matching each groupId to a set of candidate ionIds
#'
#' @export
match_id_candidates <- function(mzroll_db_con, clamr_config, nested_peakgroup_features, standards_data) {
  clamr::require_tolerances(clamr_config, required_msLevels = 1L)

  peakgroup_mzrange <- nested_peakgroup_features %>%
    tidyr::unnest_legacy(peaks) %>%
    dplyr::group_by(groupId, adductName) %>%
    dplyr::summarize(
      mzmin = min(mzmin),
      mzmax = max(mzmax)
    ) %>%
    dplyr::ungroup()

  # expand min & max values by amu/ppm tolerance
  MS1tol <- clamr_config$MS1tol
  if (MS1tol$absolute_or_relative == "relative") {
    peakgroup_mzrange$mzmin <- peakgroup_mzrange$mzmin - peakgroup_mzrange$mzmin * MS1tol$tol
    peakgroup_mzrange$mzmax <- peakgroup_mzrange$mzmax + peakgroup_mzrange$mzmax * MS1tol$tol
  } else if (MS1tol$absolute_or_relative == "absolute") {
    peakgroup_mzrange$mzmin <- peakgroup_mzrange$mzmin - MS1tol$tol
    peakgroup_mzrange$mzmax <- peakgroup_mzrange$mzmax + MS1tol$tol
  } else {
    stop(MS1tol$absolute_or_relative, " is an undefined value for MS1tol$absolute_or_relative")
  }

  # Only match based on m/z, ignore adduct type
  # find candidate standards within mz tolerance of a peakgroups mz range

  before <- Sys.time()

  id_candidates <- peakgroup_ion_prelim_search(
    peakgroups = peakgroup_mzrange,
    std_ions = standards_data$ions
  )

  after <- Sys.time()
  debugr::dwatch(msg = paste("Computed id_candidates by comparing standards DB to experimental data in ", difftime(after, before, units = "secs"), "seconds"))

  id_candidates
}

#' Compare Aligned Features
#'
#' Compares experimentally derived peaks and scans to standard compound mass, retention time and fragmentation to generate a large set of features.
#' A subset of these features will inform compound matching.
#' 
#' @param aligned_labelled_features tibble of aligned features with compound identifications.
#' @param n_top_spectra_summed number of scans to use for consensus spectrum formation.
#' @param quality_weights relative importance weight for aspects of scans data (e.g., MS2 purity, quality, etc).
#' @param MS2tol the instrument mass accuracy tolerance for the purpose of fragment grouping - \code{\link[clamr]{format_mass_accuracy_input}}, normally passed from a \code{\link[clamr]{build_clamr_config}} object.
#' @param frag_similarity_methods a character vector of methods to use for fragmentation scoring:
#' \itemize{
#'   \item{tic: fraction of experimental signal explained by standard fragments.}
#'   \item{fisher: fisher exact test to look at overlap between experimental and standard fragments.}
#'   \item{spearman: spearman correlation between experimental and standard fragments.}
#'   \item{cosine: the cosine similarity between mz-matched ions of the standard and experimental spectra.}
#'   \item{robust cosine: calculate the cosine similarity when separately dropping out each fragment - then take the worst cosine similarity among them. Identifies cases where a match score is driven by a single fragment.}
#'  }
#' @param remove_precursor Should the precursor mass be removed before matching spectra?
#' @param minimum_ic_fraction A value between 0 and 1 indicating for a given peak the fraction of total signal for it to be used for matching.
#' @param print_plot option associated with how plot should be printed.
#' 
#' @export
compare_aligned_features <- function(aligned_labelled_features, MS2tol, n_top_spectra_summed = 3L, quality_weights = c("purity" = 2, "quality" = 1),
                                     frag_similarity_methods = c("cosine", "robust_cosine"), remove_precursor = FALSE,
                                     minimum_ic_fraction = 0.001, print_plot = FALSE) {

  # aligned_labelled_features <<- aligned_labelled_features

  # features which summarize overall measures of peakgroup quality (and don't require specific standards)
  qc_features <- compare_aligned_features_peakgroup_qc(aligned_labelled_features) %>%
    tidyr::nest(qc_features = -groupId)

  # features which compare peaks and standards
  aligned_labelled_features %>%
    dplyr::mutate(
      fullscan_features = purrr::map2(peaks, stdCompounds, compare_aligned_features_fullscans),
      fragmentation_features = purrr::pmap(list(
        peaks = .$peaks,
        scans = .$scans,
        stdFragmentations = .$stdFragmentations
      ),
      compare_aligned_features_fragmentations,
      MS2tol = MS2tol,
      n_top_spectra_summed = n_top_spectra_summed,
      quality_weights = quality_weights,
      frag_similarity_methods = frag_similarity_methods,
      remove_precursor = remove_precursor,
      minimum_ic_fraction = minimum_ic_fraction,
      print_plot = print_plot
      )
    ) %>%
    dplyr::left_join(qc_features, by = "groupId")
}


peakgroup_ion_prelim_search <- function(peakgroups, std_ions) {
  # there is a tolerance problem in fuzzyjoin
  # where decimals are not used for calculating interval overlaps
  # this is solved by scaling by a large value
  large_value <- 100000

  fuzzyjoin::interval_inner_join(peakgroups %>%
    dplyr::mutate(mzmin = mzmin * large_value, mzmax = mzmax * large_value),
  std_ions %>%
    dplyr::mutate(precursorMz = precursorMz * large_value),
  by = c("mzmin" = "precursorMz", "mzmax" = "precursorMz"), maxgap = 0
  ) %>%
    dplyr::select(groupId, ionId)
}
